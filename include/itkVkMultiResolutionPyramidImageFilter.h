/*=========================================================================
 *
 *  Copyright NumFOCUS
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/
#ifndef itkVkMultiResolutionPyramidImageFilter_h
#define itkVkMultiResolutionPyramidImageFilter_h

#include "itkMultiResolutionPyramidImageFilter.h"

#include "itkDiscreteGaussianImageFilter.h"
#include "itkFFTDiscreteGaussianImageFilter.h"
#include "itkVector.h"
#include "itkMacro.h"
#include "VkFFTBackendExport.h"

namespace itk
{
/**\class VkMultiResolutionPyramidImageFilterEnums
 * \brief Contains all enum classes used by FFTDiscreteGaussianImageFilter class.
 * \ingroup ITKSmoothing
 */
class VkMultiResolutionPyramidImageFilterEnums
{
public:
  /**
   * \class KernelThresholdType
   * \ingroup ITKSmoothing
   * ITK defines multiple possible sources for generating a
   * Gaussian kernel for smoothing.
   *
   * Generating an ND kernel by multiplying
   * N 1D directional operators produces nearly identical
   * results to the DiscreteGaussianImageFilter class.
   *
   * Generating an ND kernel image directly with
   * GaussianImageSource relies on a slightly different
   * spatial function and will produce different smoothing,
   * but kernel generation will be faster.
   */
  enum class KernelThresholdType : uint8_t
  {
    ANY = 0,
    ALL,
  };
};
// Define how to print enumeration
extern VkFFTBackend_EXPORT std::ostream &
operator<<(std::ostream & out, const VkMultiResolutionPyramidImageFilterEnums::KernelThresholdType value);


/** \class VkMultiResolutionPyramidImageFilter
 * \brief Framework for creating images in a multi-resolution
 * pyramid.
 *
 * VkMultiResolutionPyramidImageFilter provides a generic framework to
 * to create a image pryamid according to a user defined
 * multi-resolution schedule.
 *
 * The multi-resolution schedule is specified in terms for
 * shrink factors at each multi-resolution level for each dimension.
 *
 * A user can either use the default schedules or specify
 * each factor in the schedules directly.
 *
 * The schedule is stored as an unsigned int matrix.
 * An element of the table can be access via the double bracket
 * notation: table[resLevel][dimension]
 *
 * For example:
 *   8 4 4
 *   4 4 2
 *
 * is a schedule for two computation level. In the first (coarsest)
 * level the image is reduce by a factor of 8 in the column dimension,
 * factor of 4 in the row dimension and factor of 4 in the slice dimension.
 * In the second level, the image is reduce by a factor of 4 in the column
 * dimension, 4 is the row dimension and 2 in the slice dimension.
 *
 * The method SetNumberOfLevels() set the number of
 * computation levels in the pyramid. This method will
 * allocate memory for the multi-resolution schedule table.
 * This method generates defaults tables with the starting
 * shrink factor for all dimension set to  2^(NumberOfLevel - 1).
 * All factors are halved for all subsequent levels.
 * For example if the number of levels was set to 4, the default table is:
 *
 * 8 8 8
 * 4 4 4
 * 2 2 2
 * 1 1 1
 *
 * The user can get a copy of the schedule via GetSchedule()
 * They may make alteration and reset it using SetSchedule().
 *
 * A user can create a default table by specifying the starting
 * shrink factors via methods SetStartingShrinkFactors()
 * The factors for subsequent level is generated by
 * halving the factor or setting to one, depending on which is larger.
 *
 * For example, for 4 levels and starting factors of 8,8,4
 * the default table would be:
 *
 * 8 8 4
 * 4 4 2
 * 2 2 1
 * 1 1 1
 *
 * When this filter is updated, NumberOfLevels outputs are produced.
 * The N'th output correspond to the N'th level of the pyramid.
 *
 * To generate each output image, Gaussian smoothing is first performed
 * using a DiscreteGaussianImageFilter with variance (shrink factor / 2)^2.
 * The smoothed image is then downsampled using a ResampleImageFilter.
 *
 * Note that even if the shrink factors are all equal to one, a smoothing
 * will still be applied. The output at the finest level of the pyramid
 * will thus typically be a smoothed version of the input.
 *
 * This class is templated over the input image type and the output image
 * type.
 *
 * This filter uses multithreaded filters to perform the smoothing and
 * downsampling.
 *
 * This filter supports streaming.
 *
 * \sa MultiResolutionPyramidImageFilter
 * \sa DiscreteGaussianImageFilter
 * \sa ShrinkImageFilter
 *
 * \ingroup PyramidImageFilter MultiThreaded Streamed
 * \ingroup ITKRegistrationCommon
 */
template <typename TInputImage, typename TOutputImage>
class ITK_TEMPLATE_EXPORT VkMultiResolutionPyramidImageFilter
  : public MultiResolutionPyramidImageFilter<TInputImage, TOutputImage>
{
public:
  ITK_DISALLOW_COPY_AND_MOVE(VkMultiResolutionPyramidImageFilter);

  /** Standard class type aliases. */
  using Self = VkMultiResolutionPyramidImageFilter;
  using Superclass = MultiResolutionPyramidImageFilter<TInputImage, TOutputImage>;
  using Pointer = SmartPointer<Self>;
  using ConstPointer = SmartPointer<const Self>;

  /** Method for creation through the object factory. */
  itkNewMacro(Self);

  /** Run-time type information (and related methods). */
  itkTypeMacro(VkMultiResolutionPyramidImageFilter, MultiResolutionPyramidImageFilter);

  /** ImageDimension enumeration. */
  static constexpr unsigned int ImageDimension = TInputImage::ImageDimension;

  /** Inherit types from Superclass. */
  using typename Superclass::InputImageType;
  using typename Superclass::OutputImageType;
  using typename Superclass::InputImagePointer;
  using typename Superclass::OutputImagePointer;
  using typename Superclass::InputImageConstPointer;
  using OutputPixelType = typename OutputImageType::PixelType;
  using OutputSizeType =  typename OutputImageType::SizeType;
  using typename Superclass::ScheduleType;
  using VarianceType = itk::Vector<double, ImageDimension>;

  /** Types for acceleration.
   *  Assumes and does not verify that FFT backend is accelerated. */
  using BaseSmootherType = DiscreteGaussianImageFilter<OutputImageType, OutputImageType>;
  using SpatialSmootherType = DiscreteGaussianImageFilter<OutputImageType, OutputImageType>;
  using FFTSmootherType = FFTDiscreteGaussianImageFilter<OutputImageType, OutputImageType>;

  /** Set the kernel radius size threshold to decide between
   *  accelerated methods such as CPU-based separable smoothing
   *  versus GPU-based FFT smoothing. Should be adjusted to match
   *  benchmarks for individual hardware setup. Defaults to 10.
   */
  itkSetMacro(KernelRadiusThreshold, OutputSizeType);
  itkGetConstMacro(KernelRadiusThreshold, OutputSizeType);

  /** Set the condition for which threshold values will trigger
   *  different pipeline executions. ANY indicates that a kernel radius
   *  size greater than the specified threshold in any direction will
   *  prompt using FFT blurring. ALL indicates that FFT blurring will
   *  only be used if the kernel radius is greater than the threshold
   *  in every direction. */
  using KernelThresholdType = VkMultiResolutionPyramidImageFilterEnums::KernelThresholdType;
  itkSetMacro(KernelThresholdCondition, KernelThresholdType);
  itkGetConstMacro(KernelThresholdCondition, KernelThresholdType);

  /** Estimate the kernel radius from ilevel settings */
  OutputSizeType
  GetKernelRadius(unsigned int ilevel) const;

  /** Get the kernel variance for the given pyramid level
   *  based on the current schedule */
  VarianceType
  GetVariance(unsigned int ilevel) const;

protected:
  VkMultiResolutionPyramidImageFilter();
  ~VkMultiResolutionPyramidImageFilter() override = default;

  /** Generate the output data. */
  void
  GenerateData() override;

  void
  PrintSelf(std::ostream & os, Indent indent) const override;

protected:
  OutputSizeType m_KernelRadiusThreshold;
  KernelThresholdType m_KernelThresholdCondition = VkMultiResolutionPyramidImageFilterEnums::KernelThresholdType::ANY;
};
} // namespace itk

#ifndef ITK_MANUAL_INSTANTIATION
#  include "itkVkMultiResolutionPyramidImageFilter.hxx"
#endif

#endif
